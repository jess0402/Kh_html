<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>정규표현식</title>
  <style>
    .area {
      background-color: lightgray;
      border: 2px solid #000;
      padding: 5px;
      margin: 10px 0;
      min-height: 50px;
    }
  </style>
</head>
<body>
  <h1>정규표현식 - Regular Expression</h1>
  <!--
    정규표현식
      - 정규표현식은 특정규칙을 가진 문자열집합을 표현하는 표현식
      - 언어독립적 - 언어를 막론하고 다 사용할 수 있다.
      - 유효셩검사, 검색, 문자열대체 등에 사용됨.
      - 일반적인 조건문 사용보다 훨씬 간결하게 표현가능하지만, 문법자체 숙지 어렵다.
  -->
  <button id="btn1">맛보기</button>
  <script>
    /**
     * 정규표현식 객체 만들기 (세 가지 방법)
     *  1. /정규표현식/gi
     *  2. new RegExp(/정규표현식/gi)
     *  3. new RegExp("정규표현식", "gi")
     */
    btn1.onclick = () => {
      const regexp1 = /[0-9]/g;
      const regexp2 = new RegExp(/[0-9]/);
      const regexp3 = new RegExp("/[0-9]/");

      console.dir(regexp1);
      console.dir(regexp2);
      console.dir(regexp3);

      const str1 = "abcde123";
      const str2 = "xyz";

      // 숫자포함여부
      // RegExp#test:boolean을 리턴 
      console.log(regexp1.test(str1));  // true
      console.log(regexp1.test(str2));  // false

      // RegExp#exec:[](배열)을 리턴
      console.log(regexp1.exec(str1));  // ['1', index: 5, input: 'abcde123', groups: undefined] -> 1이 찾아졌고, index는 5였다.
      console.log(regexp1.exec(str2));  // null

      // String#match:[](배열)을 리턴
      console.log(str1.match(regexp1));
      // const regexp1 = /[0-9]/g; (g옵션을 안 줬을 경우) -> ['1', index: 5, input: 'abcde123', groups: undefined]
      // const regexp1 = /[0-9]/g; (g옵션을 줄 경우) -> ['1', '2', '3']

      // String#number:index를 리턴 -> 인덱스
      console.log(str1.search(regexp1));  // 5 (만약 여러 글자면 가장 처음으로 만나는 글자의 인덱스를 반환)

      // String#replace:String을 리턴 -> 텍스트 대체
      console.log(str1.replace(regexp1, "*")); 
      // 정규표현식과 일치하는 문자열을 찾았다면, *로 바꿔주세요
      // const regexp1 = /[0-9]/g; (g옵션을 안 줬을 경우) -> abcde*23
      // const regexp1 = /[0-9]/g; (g옵션을 줄 경우) -> abcde***

      // String#split:[](배열)을 리턴 -> 구분자로 조개기
      console.log(str1.split(regexp1));  // ['abcde', '', '', ''] 
    }
  </script>

  <button id="btn2">대체문자</button>
  <div class="area" id="area2"></div>
  <script>
    /**
     * replace에 사용하는 대체문자
     *  - $& = 매칭된 문자열을 의미
     *  - $` = 매칭된 문자열 앞부분
     *  - $' = 매칭된 문자열 뒷부분
     */
    btn2.onclick = () => {
      const str = 'javascript jquery ajax css sass';
      const regexp = new RegExp(/as/); 

      area2.innerHTML = `${str.replace(regexp, '<mark>$&</mark>')}<br>`;
      // g를 쓰지 않아서 첫 번째로 나오는 as만 mark태그가 적용이 됨.

      area2.innerHTML += `${str.replace(regexp, '<mark>$`</mark>')}<br>`;
      // regexp인 as가 매칭되고, 그 앞부분인 jav가 $`에 해당되어 as 부분을 jav로 대체된 뒤 mark태그가 적용됨.

      area2.innerHTML += `${str.replace(regexp, "<mark>$'</mark>")}<br>`;
      // regexp의 as가 매칭되어 그 뒷부분이 몽땅 $' 해당되어 as 부분이 모두 그걸로 대체되고 mark태그가 적용됨.


      // 콜백함수처리 (대체문자 없이)
      area2.innerHTML += `${str.replace(regexp, (str) => "<mark>" + str + "</mark>")}<br>`;
      // str에 매칭된 텍스트가 넘어오니까 그 부분을 mark로 감싸주세요..?
    }
  </script>
  
  <button id="btn3">flag</button>
  <div id="area3" class="area"></div>
  <script>
    const SUBSTITUTE = '<mark>$&</mark>';
    /**
     * flag문자 
     *  - 정규표현식에 대한 옵션
     *  - g : global(전역비교수행. g가 없으면 처음 매칭된 1건만 처리. g가 있으면 해당 텍스트 내에서 여러번 매칭을 해낼 수 있음)
     *  - i : ignore(대소문자 구분하지 않고 처리)
     *  - m : multiling(여러줄인 경우 행단위 비교 수행)
     */
    btn3.onclick = () => {
      const str = "Javascript jQuery Ajax sass"; 
      area3.innerHTML = `${str.replace(/a/, SUBSTITUTE)}<br>` // 한 건에 대해서만 처리됨. 
      area3.innerHTML += `${str.replace(/a/g, SUBSTITUTE)}<br>` // 여러 건에 대해서 처리됨.
      area3.innerHTML += `${str.replace(/a/gi, SUBSTITUTE)}<br>` // 대소문자 구분 xx.
      area3.innerHTML += `${str.replace(new RegExp("a", "g"), SUBSTITUTE)}<br>` // 대소문자 구분 xx.
    };
  </script>

  <button id="btn4">anchor</button>
  <div id="area4" class="area"></div>
  <script>
    /**
     * anchor문자
     *  - ^ : 문자열의 시작
     *  - $ : 문자열의 끝 
     */
    btn4.onclick = () => {
      const str = 'Javascript xxx jQuery Ajax';
      
      area4.innerHTML = `${str.replace(/^j/gi, SUBSTITUTE)}<br>`
      // ^j = 문자열을 시작하는 j만 찾는다.
      
      area4.innerHTML += `${str.replace(/x$/gi, SUBSTITUTE)}<br>`
      // x$ = 문자열의 맨 뒤에 있는 x만 찾는다.


      const str2 = `Javascript
      xxx
      jQuery
      Ajax`;
      // 여러줄에 대해서 검사
      area4.innerHTML += `${str2.replace(/^j/gim, SUBSTITUTE)}<br>`
      area4.innerHTML += `${str2.replace(/x$/gim, SUBSTITUTE)}<br>`
    };
  </script>

  <button id="btn5">.</button>
  <script>
    /**
     * .(마침표)
     *  - 임의의 한글자 의미
     *  - 어떤 글자든 가능. 공백 ok, 문자 ok, 특수문자 ok 모두 ok. 문자 하나를 가리킨다.
     */
    btn5.onclick = () => {
      const regexp = /^a.b/;
      // a로 시작하고 한 글자가 있고 그 뒤에 b가 있는가

      console.log('acb', regexp.test('acb'));   // true
      console.log('acba', regexp.test('acba')); // true 
      console.log('acbaaaaaaaa', regexp.test('acbaaaaaaaaaa'));  // true
      // b 뒤에 몇 글자가 나오든, 뭐가 나오든 상관없음. a로 시작하고 한 글자가 나오고 b가 나오는것만 만족하면 true가 나옴. 
      console.log('aaba', regexp.test('aaba')); // true
      console.log('ab', regexp.test('ab')); // false
      console.log('a b', regexp.test('a b')); // true - 공백도 하나의 문자로 인정받음
      console.log('a\nb', regexp.test('a\nb')); // false - 공백은 하나의 문자이지만 개행은 하나의 문자가 아님. 그래서 false

    };
  </script>


</body>
</html>